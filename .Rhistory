k <- k+1
# The colum name is the variable name + variable level (like in model.matrix)
colName[k]<- paste(colnames(new_data)[i], unique(new_data[,i]),sep="")[j]
# TRUE if the colum value belongs to the level of the variable, FALSE otherwise
X_model_matrix[,k] <- new_data[,i]==unique(new_data[j,i])
# Setts TRUE to 1 and FALSE to 0
X_model_matrix[,k] <- as.integer(as.logical(X_model_matrix[,k]))
}
# If not character
} else {
# Moves to the next row
k <- k+1
# The values is the values from new_data
X_model_matrix[,k] <- new_data[,i]
# The colum name is the same as in new_data
colName[k] <- colnames(new_data)[i]
}
}
colnames(X_model_matrix)<-colName
Y_new <<- as.matrix(X_model_matrix)%*%as.matrix(result$beta_hat[match(rownames(result$beta_hat),colnames(X_model_matrix), nomatch=0)])
X_model_matrix
model <- ridgereg(data=train_data, formula=dep_delay~origin+temp+wind_speed+precip+pressure+visib+wind_pre+wind_vis, lambda=0)
print(model)
data<-train_data
df_name <- as.character(substitute(data))
scale_d <- data
for(i in 1:ncol(data)){
if(is.numeric(data[,i])){
scale_d[,i] <- scale(data[,i])
}
}
scale_data <- scale_d
X <- model.matrix(formula, scale_data)               # Independen variable(s)
y <- data[,all.vars(formula)[1]]
result<-list()
result$beta_hat <- solve(t(X)%*%X+lambda*diag(ncol(X)))%*%t(X)%*%y
as.matrix(X_model_matrix)%*%as.matrix(result$beta_hat[match(rownames(result$beta_hat),colnames(X_model_matrix), nomatch=0)])
X_model_matrix
result$beta_hat[match(rownames(result$beta_hat),colnames(X_model_matrix), nomatch=0)]
as.matrix(X_model_matrix)
result$beta_hat[match(rownames(result$beta_hat),colnames(X_model_matrix), nomatch=0)]
rownames(result$beta_hat)
colnames(X_model_matrix)
match(rownames(result$beta_hat),colnames(X_model_matrix), nomatch=0)
result$beta_hat[match(rownames(result$beta_hat),colnames(X_model_matrix), nomatch=0)]
rownames(result$beta_hat)
match(rownames(result$beta_hat),colnames(X_model_matrix), nomatch=0)]
match(rownames(result$beta_hat),colnames(X_model_matrix), nomatch=0)
result$beta_hat
result$beta_hat[match(rownames(result$beta_hat),colnames(X_model_matrix), nomatch=0)]
as.matrix(result$beta_hat[match(rownames(result$beta_hat),colnames(X_model_matrix), nomatch=0)])
dims(as.matrix(result$beta_hat[match(rownames(result$beta_hat),colnames(X_model_matrix), nomatch=0)]))
dim(as.matrix(result$beta_hat[match(rownames(result$beta_hat),colnames(X_model_matrix), nomatch=0)]))
dim(as.matrix(X_model_matrix))
as.matrix(X_model_matrix)
result$beta_hat
as.matrix(result$beta_hat[match(rownames(result$beta_hat),colnames(X_model_matrix), nomatch=0)])
result$beta_hat
head(X_model_matrix)
rownames(result$beta_hat)
colnames(X_model_matrix)
match(rownames(result$beta_hat),colnames(X_model_matrix), nomatch=0)]
match(rownames(result$beta_hat),colnames(X_model_matrix), nomatch=0)
X_model_matrix[match(rownames(result$beta_hat),colnames(X_model_matrix), nomatch=0)]
as.matrix(X_model_matrix[match(rownames(result$beta_hat),colnames(X_model_matrix), nomatch=0)])%*%as.matrix(result$beta_hat)
devtools::load_all(".")
library(BonusLab)
library(nycflights13)
library(dplyr)
library(caret)
data(weather)
data(flights)
# data with weather
dww <- left_join(flights, weather, by=c("time_hour"="time_hour", "origin"="origin")) %>%
select(dep_delay, origin, temp, wind_speed, precip, pressure, visib) %>%
stats::na.omit() %>% mutate(wind_pre = wind_speed*precip,
wind_vis = wind_speed*visib)
# row in data: 100%
rows_in_data <- 1:nrow(dww)
# test or validation: 100%*0.2 = 20%
test_val_Index <- caret::createDataPartition(rows_in_data, p = .2,
list = FALSE,
times = 1)
# Train: 100%-20% = 80%
train_index <- rows_in_data[-test_val_Index]
# validation: 0.75*20% = 15%
val_index <- caret::createDataPartition(test_val_Index, p = .75,
list = FALSE,
times = 1)
# test: 0.25*20% = 5%
test_index <- test_val_Index[-val_index]
data.frame(val=length(val_index)/length(rows_in_data),
train=length(train_index)/length(rows_in_data),
test=length(test_index)/length(rows_in_data))
train_data <- as.data.frame(dww[train_index,])
val_data <- as.data.frame(dww[val_index,])
test_data <- as.data.frame(dww[test_index,])
model <- ridgereg(data=train_data, formula=dep_delay~origin+temp+wind_speed+precip+pressure+visib+wind_pre+wind_vis, lambda=0)
print(model)
model$predict(val_data[,-1])
as.matrix(result$beta_hat)
as.matrix(X_model_matrix[match(rownames(result$beta_hat),colnames(X_model_matrix), nomatch=0)])
head(as.matrix(X_model_matrix[match(rownames(result$beta_hat),colnames(X_model_matrix), nomatch=0)]))
as.matrix(result$beta_hat)
as.matrix(X_model_matrix[match(rownames(result$beta_hat),colnames(X_model_matrix), nomatch=0)])%*%as.matrix(result$beta_hat)
head(as.matrix(X_model_matrix[match(rownames(result$beta_hat),colnames(X_model_matrix), nomatch=0)]))
as.matrix(result$beta_hat)
lm(data=train_data, formula=dep_delay~origin+temp+wind_speed+precip+pressure+visib+wind_pre+wind_vis)
lm(data=scale(train_data), formula=dep_delay~temp+wind_speed+precip+pressure+visib+wind_pre+wind_vis)
ridgereg <- setRefClass("ridgereg",
fields = list(result ="list",
data = "data.frame",
df_name ="character",
formula = "formula",
beta_hat = "matrix",
y_hat ="matrix",
X = "matrix",
y = "numeric",
lambda="numeric",
scale_data="data.frame",
new_data="data.frame",
X_new="matrix",
Y_new="matrix"
),
methods = list(
initialize = function(formula, data, lambda=0){
lambda <<- lambda
formula <<- formula
df_name <<- as.character(substitute(data))
scale_d <- data
# for(i in 1:ncol(data)){
#   if(is.numeric(data[,i])){
#     scale_d[,i] <- scale(data[,i])
#   }
# }
scale_data <<- scale_d
X <<- model.matrix(formula, scale_data)               # Independen variable(s)
y <<- data[,all.vars(formula)[1]]                     # Dependent variable
# Beta (Regression coefficients)
result$beta_hat <<- solve(t(X)%*%X+lambda*diag(ncol(X)))%*%t(X)%*%y
},
show = function(){
cat("Call:\nridgereg(formula = ", format(formula), ", data = ", df_name,", lambda = ",lambda,")\n\n", sep="")
temp <- as.data.frame(t(data.frame(result$beta_hat)))
rownames(temp) <- ""
colnames(temp) <- colnames(X)
cat("Coefficients:\n")
print.data.frame(temp)
},
predict = function(new_data){
if(!all(attr(terms(formula), which = "term.labels") %in% colnames(new_data))){
stop("Invalid new_data input")}
# Data.frame of reoderd new_data
X_model_matrix <- data.frame()
# First column=Intercept
X_model_matrix[1:nrow(new_data),1] <- rep(1, nrow(new_data))
colName <- c("(Intercept)")
# Set counter for colums in new_data
k<-1
# Operates over all colums of new_data
for(i in 1:ncol(new_data)){
# If the coloum is a character
if(is.character(new_data[,i])){
# Operates over all levels of new_data
for(j in 1:length(unique(new_data[,i]))){
# Moves to the next column (first one 2 due to the intercept)
k <- k+1
# The colum name is the variable name + variable level (like in model.matrix)
colName[k]<- paste(colnames(new_data)[i], unique(new_data[,i]),sep="")[j]
# TRUE if the colum value belongs to the level of the variable, FALSE otherwise
X_model_matrix[,k] <- new_data[,i]==unique(new_data[j,i])
# Setts TRUE to 1 and FALSE to 0
X_model_matrix[,k] <- as.integer(as.logical(X_model_matrix[,k]))
}
# If not character
} else {
# Moves to the next row
k <- k+1
# The values is the values from new_data
X_model_matrix[,k] <- new_data[,i]
# The colum name is the same as in new_data
colName[k] <- colnames(new_data)[i]
}
}
# Sets colum names
colnames(X_model_matrix)<-colName
# Calculate predicted value by new_data times the corresponding beta parameter
Y_new <<- as.matrix(X_model_matrix[match(rownames(result$beta_hat),colnames(X_model_matrix), nomatch=0)])%*%as.matrix(result$beta_hat)
return(data.frame(Predictions=Y_new))
},
coef = function(){
return(result$beta_hat)
}
)
)
model <- ridgereg(data=train_data, formula=dep_delay~origin+temp+wind_speed+precip+pressure+visib+wind_pre+wind_vis, lambda=0)
print(model)
model$predict(val_data[,-1])
library(MASS)
lm.ridge(data=train_data, formula=dep_delay~origin+temp+wind_speed+precip+pressure+visib+wind_pre+wind_vis, lambda=0)
library(BonusLab)
library(nycflights13)
library(dplyr)
library(caret)
model$predict(val_data)
library(BonusLab)
library(nycflights13)
library(dplyr)
library(caret)
data(weather)
data(flights)
# data with weather
dww <- left_join(flights, weather, by=c("time_hour"="time_hour", "origin"="origin")) %>%
select(dep_delay, origin, temp, wind_speed, precip, pressure, visib) %>%
stats::na.omit() %>% mutate(wind_pre = wind_speed*precip,
wind_vis = wind_speed*visib)
# row in data: 100%
rows_in_data <- 1:nrow(dww)
# test or validation: 100%*0.2 = 20%
test_val_Index <- caret::createDataPartition(rows_in_data, p = .2,
list = FALSE,
times = 1)
# Train: 100%-20% = 80%
train_index <- rows_in_data[-test_val_Index]
# validation: 0.75*20% = 15%
val_index <- caret::createDataPartition(test_val_Index, p = .75,
list = FALSE,
times = 1)
# test: 0.25*20% = 5%
test_index <- test_val_Index[-val_index]
data.frame(val=length(val_index)/length(rows_in_data),
train=length(train_index)/length(rows_in_data),
test=length(test_index)/length(rows_in_data))
train_data <- as.data.frame(dww[train_index,])
val_data <- as.data.frame(dww[val_index,])
test_data <- as.data.frame(dww[test_index,])
model <- ridgereg(data=train_data, formula=dep_delay~origin+temp+wind_speed+precip+pressure+visib+wind_pre+wind_vis, lambda=0)
print(model)
model$predict(val_data)
model$predict(val_data[,-1])
model$predict(val_data)
ridgereg <- setRefClass("ridgereg",
fields = list(result ="list",
data = "data.frame",
df_name ="character",
formula = "formula",
beta_hat = "matrix",
y_hat ="matrix",
X = "matrix",
y = "numeric",
lambda="numeric",
scale_data="data.frame",
new_data="data.frame",
X_new="matrix",
Y_new="matrix"
),
methods = list(
initialize = function(formula, data, lambda=0){
lambda <<- lambda
formula <<- formula
df_name <<- as.character(substitute(data))
scale_d <- data
# for(i in 1:ncol(data)){
#   if(is.numeric(data[,i])){
#     scale_d[,i] <- scale(data[,i])
#   }
# }
scale_data <<- scale_d
X <<- model.matrix(formula, scale_data)               # Independen variable(s)
y <<- data[,all.vars(formula)[1]]                     # Dependent variable
# Beta (Regression coefficients)
result$beta_hat <<- solve(t(X)%*%X+lambda*diag(ncol(X)))%*%t(X)%*%y
},
show = function(){
cat("Call:\nridgereg(formula = ", format(formula), ", data = ", df_name,", lambda = ",lambda,")\n\n", sep="")
temp <- as.data.frame(t(data.frame(result$beta_hat)))
rownames(temp) <- ""
colnames(temp) <- colnames(X)
cat("Coefficients:\n")
print.data.frame(temp)
},
predict = function(new_data){
if(!all(attr(terms(formula), which = "term.labels") %in% colnames(new_data))){
stop("Invalid new_data input")}
# Data.frame of reoderd new_data
X_model_matrix <- data.frame()
# First column=Intercept
X_model_matrix[1:nrow(new_data),1] <- rep(1, nrow(new_data))
colName <- c("(Intercept)")
# Set counter for colums in new_data
k<-1
# Operates over all colums of new_data
for(i in 1:ncol(new_data)){
# If the coloum is a character
if(is.character(new_data[,i])){
# Operates over all levels of new_data
for(j in 1:length(unique(new_data[,i]))){
# Moves to the next column (first one 2 due to the intercept)
k <- k+1
# The colum name is the variable name + variable level (like in model.matrix)
colName[k]<- paste(colnames(new_data)[i], unique(new_data[,i]),sep="")[j]
# TRUE if the colum value belongs to the level of the variable, FALSE otherwise
X_model_matrix[,k] <- new_data[,i]==unique(new_data[j,i])
# Setts TRUE to 1 and FALSE to 0
X_model_matrix[,k] <- as.integer(as.logical(X_model_matrix[,k]))
}
# If not character
} else {
# Moves to the next row
k <- k+1
# The values is the values from new_data
X_model_matrix[,k] <- new_data[,i]
# The colum name is the same as in new_data
colName[k] <- colnames(new_data)[i]
}
}
# Sets colum names
colnames(X_model_matrix)<-colName
# Calculate predicted value by new_data times the corresponding beta parameter
Y_new <<- as.matrix(X_model_matrix[match(rownames(result$beta_hat),colnames(X_model_matrix), nomatch=0)])%*%as.matrix(result$beta_hat)
return(data.frame(Predictions=Y_new))
},
coef = function(){
return(result$beta_hat)
}
)
)
model$predict(val_data)
model <- ridgereg(data=train_data, formula=dep_delay~origin+temp+wind_speed+precip+pressure+visib+wind_pre+wind_vis, lambda=0)
print(model)
model$predict(val_data)
train_data
mean(train_data$temp)
mean<-mean(train_data$temp)
sd<-sd(train_data$temp)
(0.1153062+mean)/sd
RMSE_flight_delay <- function(model, validation=TRUE){
if(validation==FALSE){
data <- test_data
} else if (validation==TRUE){
data <- val_data
}
actual <- data$dep_delay
pred <- model$predict(data)
return(sqrt(sum((pred-actual)^2/length(actual))))
}
RMSE_flight_delay(model)
# RMSE on validation data
RMSE_flight_delay(model, validation=TRUE)
# RMSE on validation data
RMSE_flight_delay(model, validation=FALSE)
# RMSE on validation data
RMSE_flight_delay(model, validation=TRUE)
RMSE_table <- data.frame(lambda=c(1,5,10,25,50,100),
val_RMSE=c(RMSE1, RMSE2, RMSE3, RMSE4, RMSE5, RMSE6))
model1 <- ridgereg(data=train_data, formula=dep_delay~origin+temp+wind_speed+precip+pressure+visib+wind_pre+wind_vis, lambda=1)
model2 <- ridgereg(data=train_data, formula=dep_delay~origin+temp+wind_speed+precip+pressure+visib+wind_pre+wind_vis, lambda=5)
model3 <- ridgereg(data=train_data, formula=dep_delay~origin+temp+wind_speed+precip+pressure+visib+wind_pre+wind_vis, lambda=10)
model4 <- ridgereg(data=train_data, formula=dep_delay~origin+temp+wind_speed+precip+pressure+visib+wind_pre+wind_vis, lambda=25)
model5 <- ridgereg(data=train_data, formula=dep_delay~origin+temp+wind_speed+precip+pressure+visib+wind_pre+wind_vis, lambda=50)
model6 <- ridgereg(data=train_data, formula=dep_delay~origin+temp+wind_speed+precip+pressure+visib+wind_pre+wind_vis, lambda=100)
RMSE1 <- RMSE_flight_delay(model1, validation=TRUE)
RMSE2 <- RMSE_flight_delay(model2, validation=TRUE)
RMSE3 <- RMSE_flight_delay(model3, validation=TRUE)
RMSE4 <- RMSE_flight_delay(model4, validation=TRUE)
RMSE5 <- RMSE_flight_delay(model5, validation=TRUE)
RMSE6 <- RMSE_flight_delay(model6, validation=TRUE)
RMSE_table <- data.frame(lambda=c(1,5,10,25,50,100),
val_RMSE=c(RMSE1, RMSE2, RMSE3, RMSE4, RMSE5, RMSE6))
library(BonusLab)
library(nycflights13)
library(dplyr)
library(caret)
library(knitr)
RMSE_table <- data.frame(lambda=c(1,5,10,25,50,100),
val_RMSE=c(RMSE1, RMSE2, RMSE3, RMSE4, RMSE5, RMSE6))
kable(RMSE_table)
RMSE_table <- data.frame(lambda=c(1,5,10,25,50,100),
`Validarion RMSE`=c(RMSE1, RMSE2, RMSE3, RMSE4, RMSE5, RMSE6))
kable(RMSE_table)
RMSE_table <- data.frame(lambda=c(1,5,10,25,50,100),
´Validarion RMSE´=c(RMSE1, RMSE2, RMSE3, RMSE4, RMSE5, RMSE6))
RMSE_table <- data.frame(lambda=c(1,5,10,25,50,100),
`Validarion RMSE`=c(RMSE1, RMSE2, RMSE3, RMSE4, RMSE5, RMSE6))
kable(RMSE_table)
model1 <- ridgereg(data=train_data, formula=dep_delay~origin+temp+wind_speed+precip+pressure+visib+wind_pre+wind_vis, lambda=1)
model2 <- ridgereg(data=train_data, formula=dep_delay~origin+temp+wind_speed+precip+pressure+visib+wind_pre+wind_vis, lambda=5)
model3 <- ridgereg(data=train_data, formula=dep_delay~origin+temp+wind_speed+precip+pressure+visib+wind_pre+wind_vis, lambda=10)
model4 <- ridgereg(data=train_data, formula=dep_delay~origin+temp+wind_speed+precip+pressure+visib+wind_pre+wind_vis, lambda=25)
model5 <- ridgereg(data=train_data, formula=dep_delay~origin+temp+wind_speed+precip+pressure+visib+wind_pre+wind_vis, lambda=50)
model6 <- ridgereg(data=train_data, formula=dep_delay~origin+temp+wind_speed+precip+pressure+visib+wind_pre+wind_vis, lambda=100)
model7 <- ridgereg(data=train_data, formula=dep_delay~origin+temp+wind_speed+precip+pressure+visib+wind_pre+wind_vis, lambda=200)
model8 <- ridgereg(data=train_data, formula=dep_delay~origin+temp+wind_speed+precip+pressure+visib+wind_pre+wind_vis, lambda=500)
model9 <- ridgereg(data=train_data, formula=dep_delay~origin+temp+wind_speed+precip+pressure+visib+wind_pre+wind_vis, lambda=1000)
RMSE1 <- RMSE_flight_delay(model1, validation=TRUE)
RMSE2 <- RMSE_flight_delay(model2, validation=TRUE)
RMSE3 <- RMSE_flight_delay(model3, validation=TRUE)
RMSE4 <- RMSE_flight_delay(model4, validation=TRUE)
RMSE5 <- RMSE_flight_delay(model5, validation=TRUE)
RMSE6 <- RMSE_flight_delay(model6, validation=TRUE)
RMSE7 <- RMSE_flight_delay(model7, validation=TRUE)
RMSE8 <- RMSE_flight_delay(model8, validation=TRUE)
RMSE9 <- RMSE_flight_delay(model9, validation=TRUE)
RMSE_table <- data.frame(lambda=c(1,5,10,25,50,100,200,500,10000),
`Validarion RMSE`=c(RMSE1, RMSE2, RMSE3, RMSE4, RMSE5, RMSE6))
RMSE_table <- data.frame(lambda=c(1,5,10,25,50,100,200,500,10000),
`Validarion RMSE`=c(RMSE1, RMSE2, RMSE3, RMSE4, RMSE5, RMSE6, RMSE7, RMSE8, RMSE9))
kable(RMSE_table)
RMSE_table <- data.frame(lambda=c(1,5,10,25,50,100,200,500,1000),
`Validarion RMSE`=c(RMSE1, RMSE2, RMSE3, RMSE4, RMSE5, RMSE6, RMSE7, RMSE8, RMSE9))
kable(RMSE_table)
RMSE_table <- data.frame(lambda=c(1,5,10,25,50,100,200,500,1000),
`Validarion RMSE`=c(RMSE1, RMSE2, RMSE3, RMSE4, RMSE5, RMSE6, RMSE7, RMSE8, RMSE9))
kable(RMSE_table)
ridgereg <- setRefClass("ridgereg",
fields = list(result ="list",
data = "data.frame",
df_name ="character",
formula = "formula",
beta_hat = "matrix",
y_hat ="matrix",
X = "matrix",
y = "numeric",
lambda="numeric",
scale_data="data.frame",
new_data="data.frame",
X_new="matrix",
Y_new="matrix"
),
methods = list(
initialize = function(formula, data, lambda=0){
lambda <<- lambda
formula <<- formula
df_name <<- as.character(substitute(data))
scale_d <- data
for(i in 1:ncol(data)){
if(is.numeric(data[,i])){
scale_d[,i] <- scale(data[,i])
}
}
scale_data <<- scale_d
X <<- model.matrix(formula, scale_data)               # Independen variable(s)
y <<- data[,all.vars(formula)[1]]                     # Dependent variable
# Beta (Regression coefficients)
result$beta_hat <<- solve(t(X)%*%X+lambda*diag(ncol(X)))%*%t(X)%*%y
},
show = function(){
cat("Call:\nridgereg(formula = ", format(formula), ", data = ", df_name,", lambda = ",lambda,")\n\n", sep="")
temp <- as.data.frame(t(data.frame(result$beta_hat)))
rownames(temp) <- ""
colnames(temp) <- colnames(X)
cat("Coefficients:\n")
print.data.frame(temp)
},
predict = function(new_data){
if(!all(attr(terms(formula), which = "term.labels") %in% colnames(new_data))){
stop("Invalid new_data input")}
# Data.frame of reoderd new_data
X_model_matrix <- data.frame()
# First column=Intercept
X_model_matrix[1:nrow(new_data),1] <- rep(1, nrow(new_data))
colName <- c("(Intercept)")
# Set counter for colums in new_data
k<-1
# Operates over all colums of new_data
for(i in 1:ncol(new_data)){
# If the coloum is a character
if(is.character(new_data[,i])){
# Operates over all levels of new_data
for(j in 1:length(unique(new_data[,i]))){
# Moves to the next column (first one 2 due to the intercept)
k <- k+1
# The colum name is the variable name + variable level (like in model.matrix)
colName[k]<- paste(colnames(new_data)[i], unique(new_data[,i]),sep="")[j]
# TRUE if the colum value belongs to the level of the variable, FALSE otherwise
X_model_matrix[,k] <- new_data[,i]==unique(new_data[j,i])
# Setts TRUE to 1 and FALSE to 0
X_model_matrix[,k] <- as.integer(as.logical(X_model_matrix[,k]))
}
# If not character
} else {
# Moves to the next row
k <- k+1
# The values is the values from new_data
X_model_matrix[,k] <- new_data[,i]
# The colum name is the same as in new_data
colName[k] <- colnames(new_data)[i]
}
}
# Sets colum names
colnames(X_model_matrix)<-colName
# Calculate predicted value by new_data times the corresponding beta parameter
Y_new <<- as.matrix(X_model_matrix[match(rownames(result$beta_hat),colnames(X_model_matrix), nomatch=0)])%*%as.matrix(result$beta_hat)
return(data.frame(Predictions=Y_new))
},
coef = function(){
return(result$beta_hat)
}
)
)
library(BonusLab)
library(nycflights13)
library(dplyr)
library(caret)
library(knitr)
data(weather)
data(flights)
# data with weather
dww <- left_join(flights, weather, by=c("time_hour"="time_hour", "origin"="origin")) %>%
select(dep_delay, origin, temp, wind_speed, precip, pressure, visib) %>%
stats::na.omit() %>% mutate(wind_pre = wind_speed*precip,
wind_vis = wind_speed*visib)
